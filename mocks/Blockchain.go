// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import blockchain "github.com/gagarinchain/network/blockchain"
import common "github.com/gagarinchain/network/common/eth/common"
import crypto "github.com/gagarinchain/network/common/eth/crypto"
import mock "github.com/stretchr/testify/mock"
import networkcommon "github.com/gagarinchain/network/common"
import state "github.com/gagarinchain/network/blockchain/state"
import treemap "github.com/emirpasic/gods/maps/treemap"

// Blockchain is an autogenerated mock type for the Blockchain type
type Blockchain struct {
	mock.Mock
}

// AddBlock provides a mock function with given fields: block
func (_m *Blockchain) AddBlock(block *blockchain.Block) error {
	ret := _m.Called(block)

	var r0 error
	if rf, ok := ret.Get(0).(func(*blockchain.Block) error); ok {
		r0 = rf(block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Contains provides a mock function with given fields: hash
func (_m *Blockchain) Contains(hash common.Hash) bool {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(common.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetBlockByHash provides a mock function with given fields: hash
func (_m *Blockchain) GetBlockByHash(hash common.Hash) *blockchain.Block {
	ret := _m.Called(hash)

	var r0 *blockchain.Block
	if rf, ok := ret.Get(0).(func(common.Hash) *blockchain.Block); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.Block)
		}
	}

	return r0
}

// GetBlockByHeight provides a mock function with given fields: height
func (_m *Blockchain) GetBlockByHeight(height int32) []*blockchain.Block {
	ret := _m.Called(height)

	var r0 []*blockchain.Block
	if rf, ok := ret.Get(0).(func(int32) []*blockchain.Block); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*blockchain.Block)
		}
	}

	return r0
}

// GetFork provides a mock function with given fields: height, headHash
func (_m *Blockchain) GetFork(height int32, headHash common.Hash) []*blockchain.Block {
	ret := _m.Called(height, headHash)

	var r0 []*blockchain.Block
	if rf, ok := ret.Get(0).(func(int32, common.Hash) []*blockchain.Block); ok {
		r0 = rf(height, headHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*blockchain.Block)
		}
	}

	return r0
}

// GetGenesisBlock provides a mock function with given fields:
func (_m *Blockchain) GetGenesisBlock() *blockchain.Block {
	ret := _m.Called()

	var r0 *blockchain.Block
	if rf, ok := ret.Get(0).(func() *blockchain.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.Block)
		}
	}

	return r0
}

// GetGenesisBlockSignedHash provides a mock function with given fields: key
func (_m *Blockchain) GetGenesisBlockSignedHash(key *crypto.PrivateKey) *crypto.Signature {
	ret := _m.Called(key)

	var r0 *crypto.Signature
	if rf, ok := ret.Get(0).(func(*crypto.PrivateKey) *crypto.Signature); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crypto.Signature)
		}
	}

	return r0
}

// GetGenesisCert provides a mock function with given fields:
func (_m *Blockchain) GetGenesisCert() *blockchain.QuorumCertificate {
	ret := _m.Called()

	var r0 *blockchain.QuorumCertificate
	if rf, ok := ret.Get(0).(func() *blockchain.QuorumCertificate); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.QuorumCertificate)
		}
	}

	return r0
}

// GetHead provides a mock function with given fields:
func (_m *Blockchain) GetHead() *blockchain.Block {
	ret := _m.Called()

	var r0 *blockchain.Block
	if rf, ok := ret.Get(0).(func() *blockchain.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.Block)
		}
	}

	return r0
}

// GetHeadRecord provides a mock function with given fields:
func (_m *Blockchain) GetHeadRecord() *state.Record {
	ret := _m.Called()

	var r0 *state.Record
	if rf, ok := ret.Get(0).(func() *state.Record); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Record)
		}
	}

	return r0
}

// GetThreeChain provides a mock function with given fields: twoHash
func (_m *Blockchain) GetThreeChain(twoHash common.Hash) (*blockchain.Block, *blockchain.Block, *blockchain.Block) {
	ret := _m.Called(twoHash)

	var r0 *blockchain.Block
	if rf, ok := ret.Get(0).(func(common.Hash) *blockchain.Block); ok {
		r0 = rf(twoHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.Block)
		}
	}

	var r1 *blockchain.Block
	if rf, ok := ret.Get(1).(func(common.Hash) *blockchain.Block); ok {
		r1 = rf(twoHash)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*blockchain.Block)
		}
	}

	var r2 *blockchain.Block
	if rf, ok := ret.Get(2).(func(common.Hash) *blockchain.Block); ok {
		r2 = rf(twoHash)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*blockchain.Block)
		}
	}

	return r0, r1, r2
}

// GetTopCommittedBlock provides a mock function with given fields:
func (_m *Blockchain) GetTopCommittedBlock() *blockchain.Block {
	ret := _m.Called()

	var r0 *blockchain.Block
	if rf, ok := ret.Get(0).(func() *blockchain.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.Block)
		}
	}

	return r0
}

// GetTopHeight provides a mock function with given fields:
func (_m *Blockchain) GetTopHeight() int32 {
	ret := _m.Called()

	var r0 int32
	if rf, ok := ret.Get(0).(func() int32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int32)
	}

	return r0
}

// GetTopHeightBlocks provides a mock function with given fields:
func (_m *Blockchain) GetTopHeightBlocks() []*blockchain.Block {
	ret := _m.Called()

	var r0 []*blockchain.Block
	if rf, ok := ret.Get(0).(func() []*blockchain.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*blockchain.Block)
		}
	}

	return r0
}

// IsSibling provides a mock function with given fields: sibling, ancestor
func (_m *Blockchain) IsSibling(sibling *blockchain.Header, ancestor *blockchain.Header) bool {
	ret := _m.Called(sibling, ancestor)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*blockchain.Header, *blockchain.Header) bool); ok {
		r0 = rf(sibling, ancestor)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// NewBlock provides a mock function with given fields: parent, qc, data
func (_m *Blockchain) NewBlock(parent *blockchain.Block, qc *blockchain.QuorumCertificate, data []byte) *blockchain.Block {
	ret := _m.Called(parent, qc, data)

	var r0 *blockchain.Block
	if rf, ok := ret.Get(0).(func(*blockchain.Block, *blockchain.QuorumCertificate, []byte) *blockchain.Block); ok {
		r0 = rf(parent, qc, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.Block)
		}
	}

	return r0
}

// OnCommit provides a mock function with given fields: b
func (_m *Blockchain) OnCommit(b *blockchain.Block) ([]*blockchain.Block, *treemap.Map, error) {
	ret := _m.Called(b)

	var r0 []*blockchain.Block
	if rf, ok := ret.Get(0).(func(*blockchain.Block) []*blockchain.Block); ok {
		r0 = rf(b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*blockchain.Block)
		}
	}

	var r1 *treemap.Map
	if rf, ok := ret.Get(1).(func(*blockchain.Block) *treemap.Map); ok {
		r1 = rf(b)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*treemap.Map)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*blockchain.Block) error); ok {
		r2 = rf(b)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PadEmptyBlock provides a mock function with given fields: head, qc
func (_m *Blockchain) PadEmptyBlock(head *blockchain.Block, qc *blockchain.QuorumCertificate) *blockchain.Block {
	ret := _m.Called(head, qc)

	var r0 *blockchain.Block
	if rf, ok := ret.Get(0).(func(*blockchain.Block, *blockchain.QuorumCertificate) *blockchain.Block); ok {
		r0 = rf(head, qc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.Block)
		}
	}

	return r0
}

// RemoveBlock provides a mock function with given fields: block
func (_m *Blockchain) RemoveBlock(block *blockchain.Block) error {
	ret := _m.Called(block)

	var r0 error
	if rf, ok := ret.Get(0).(func(*blockchain.Block) error); ok {
		r0 = rf(block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetProposerGetter provides a mock function with given fields: proposerGetter
func (_m *Blockchain) SetProposerGetter(proposerGetter networkcommon.ProposerForHeight) {
	_m.Called(proposerGetter)
}

// UpdateGenesisBlockQC provides a mock function with given fields: certificate
func (_m *Blockchain) UpdateGenesisBlockQC(certificate *blockchain.QuorumCertificate) {
	_m.Called(certificate)
}

// ValidateGenesisBlockSignature provides a mock function with given fields: signature, address
func (_m *Blockchain) ValidateGenesisBlockSignature(signature *crypto.Signature, address common.Address) bool {
	ret := _m.Called(signature, address)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*crypto.Signature, common.Address) bool); ok {
		r0 = rf(signature, address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}
